/**
 * Author: Frano Petric
 * Version: 0.9
 * Date: 23.4.2014.
 */

#include "uimodule_ja.hpp"
#include <iostream>
#include <fstream>
#include <alvalue/alvalue.h>
#include <alcommon/alproxy.h>
#include <alcommon/albroker.h>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/thread.hpp>
#include <boost/lambda/lambda.hpp>
#include <qi/log.hpp>
#include <althread/alcriticalsection.h>

struct JointAttentionInterface::Impl {

    /**
      * IP and port of the remote NAOqi which is running on the other robot
      */
    std::string remoteIP;
    int remotePort;

    boost::shared_ptr<AL::ALBroker> brokerToRemote;

    /**
      * Proxy to local ALMemory
      */
    boost::shared_ptr<AL::ALMemoryProxy> memoryProxy;
    /**
      * Proxy to remote ALMemory (running on the other robot)
      */
    boost::shared_ptr<AL::ALMemoryProxy> memoryProxyRemote;
    /**
      * Proxy to ALBehaviorManager for running pointing behavior
      */
    boost::shared_ptr<AL::ALBehaviorManagerProxy> behaviorProxy;
    /**
      * Proxy to ALAudioPlayer for sound reproduction
      */
    boost::shared_ptr<AL::ALAudioPlayerProxy> playerProxy;

    /**
      * Module object
      */
    JointAttentionInterface &module;

    /**
      * Mutex used to lock callback functions, making them thread safe
      */
    boost::shared_ptr<AL::ALMutex> fCallbackMutex;

    bool started;
    /**
      * Function reading config file containing IP and port of the other robot
      */
    void readConfig(std::string& IP, int& port) {
        // Open config file
        std::ifstream config("/home/nao/naoqi/modules/config/remote.conf");
        // Read IP and port
        config >> IP >> port;
        qiLogWarning("Interface") << "Connecting to " << IP << ":" << port << std::endl;
        // Close
        config.close();
    }

    /**
      * Function used to call and point to other robot
      */
    void call(std::string filename, bool gesture, int value) {
        // Call by name (using unblocking call)
        //playerProxy->post.playFile(filename);
        // Run pointing behavior
        if( gesture ) {
            playerProxy->post.playFile(filename);
            behaviorProxy->runBehavior("arm_point");
        }
        else {
            if( value == 1 ) {
                playerProxy->post.playFile(filename);
                behaviorProxy->runBehavior("head_turn");
            }
            else if( value == 2) {
                playerProxy->post.playFile(filename);
                behaviorProxy->runBehavior("head_turn");
            }
        }
        qiLogWarning("Interface") << "Called" << std::endl;
    }

    /**
      * Struct constructor, initializes module instance and callback mutex
      */
    Impl(JointAttentionInterface &mod) : module(mod), fCallbackMutex(AL::ALMutex::createALMutex()) {
        // Create proxies
        try {
            memoryProxy = boost::shared_ptr<AL::ALMemoryProxy>(new AL::ALMemoryProxy(mod.getParentBroker()));
            behaviorProxy = boost::shared_ptr<AL::ALBehaviorManagerProxy>(new AL::ALBehaviorManagerProxy(mod.getParentBroker()));
            playerProxy = boost::shared_ptr<AL::ALAudioPlayerProxy>(new AL::ALAudioPlayerProxy(mod.getParentBroker()));
        }
        catch (const AL::ALError& e) {
            qiLogError("Interface") << "Error creating proxies: " << e.toString() << std::endl;
        }
        // Declare events that are generated by this module
        memoryProxy->declareEvent("StartSessionJA");
        memoryProxy->declareEvent("ChildCalledJA");
        started = false;
    }
};

JointAttentionInterface::JointAttentionInterface(boost::shared_ptr<AL::ALBroker> pBroker, const std::string& pName) :  AL::ALModule(pBroker, pName) {

    setModuleDescription("Interface module, reacting to events generated by the Logger module, calling child by either name or by using special phrases");


    functionName("startTask", getName(), "Function used to start/enable the task");
    addParam("todo", "Tell the module either to start or enable the task");
    BIND_METHOD(JointAttentionInterface::startTask);

    functionName("onTactilTouched", getName(), "FrontTactilTouched callback, starts the session");

    BIND_METHOD(JointAttentionInterface::onTactilTouched);

    functionName("callChild", getName(), "CallChild callback, plays the sound");
    addParam("key", "Memory key storing data related to the event");
    addParam("value", "Value with which event is raised");
    addParam("msg", "Message provided by the module which generated the event");
    BIND_METHOD(JointAttentionInterface::callChild);

    functionName("endSession", getName(), "EndSession callback, resets the Interface");
    BIND_METHOD(JointAttentionInterface::endSession);

    functionName("enableTask", getName(), "Method to enable the task by subscribing to the FronTactilTouched event");
    BIND_METHOD(JointAttentionInterface::enableTask);

//    functionName("setRemoteConnection", getName(), "Method to enable the task by subscribing to the FronTactilTouched event");
//    BIND_METHOD(Interface::setRemoteConnection);
}

JointAttentionInterface::~JointAttentionInterface() {
    // Cleanup code
}

void JointAttentionInterface::init() {
   // This method overrides ALModule::init
    try {
        // Create object
        impl = boost::shared_ptr<Impl>(new Impl(*this));
        // Initialize ALModule
        AL::ALModule::init();
    }
    catch (const AL::ALError& e) {
        qiLogError("JointAttentionInterface") << e.what() << std::endl;
    }
    qiLogVerbose("JointAttentionInterface") << "JointAttentionInterface initialized" << std::endl;
}

void JointAttentionInterface::startTask(const std::string &todo) {
    if(impl->started) {
        return;
    }
    impl->started = true;
    if(todo == "start") {
        // Open connection to the other robot
        impl->readConfig(impl->remoteIP, impl->remotePort);

        try {
            impl->memoryProxyRemote = boost::shared_ptr<AL::ALMemoryProxy>(new AL::ALMemoryProxy(impl->remoteIP, impl->remotePort));
        }
        catch (const AL::ALError& e) {
            qiLogError("JointAttentionInterface") << "Error connecting to the other robot: " << e.toString() << std::endl;
        }
        // Subscribe to events which can be triggered during the session
        // These events are generated by the other robot
        try {
            impl->memoryProxyRemote->subscribeToEvent("CallChildJA", "JointAttentionInterface", "callChild");
            impl->memoryProxyRemote->subscribeToEvent("EndSessionJA", "JointAttentionInterface", "endSession");
        }
        catch (const AL::ALError& e) {
            qiLogError("JointAttentionInterface") << "Error subscribing to events: " << e.toString() << std::endl;
        }
        // Raise event that the session should start
        impl->memoryProxy->raiseEvent("StartSessionJA", AL::ALValue(1));
    }
    else if(todo == "enable") {
        // Subscribe to event FronTactilTouched, which signals the start of the session
        impl->memoryProxy->subscribeToEvent("FrontTactilTouched", "JointAttentionInterface", "onTactilTouched");
    }
}

void JointAttentionInterface::onTactilTouched() {
    // Callback is thread safe as long as ALCriticalSection object exists
    AL::ALCriticalSection section(impl->fCallbackMutex);
    // Unsubscribe from the event
    impl->memoryProxy->unsubscribeToEvent("FrontTactilTouched", "JointAttentionInterface");
    // Open connection to the other robot
    impl->readConfig(impl->remoteIP, impl->remotePort);

    try {
        impl->memoryProxyRemote = boost::shared_ptr<AL::ALMemoryProxy>(new AL::ALMemoryProxy(impl->remoteIP, impl->remotePort));
    }
    catch (const AL::ALError& e) {
        qiLogError("JointAttentionInterface") << "Error connecting to the other robot: " << e.toString() << std::endl;
    }
    // Subscribe to events which can be triggered during the session
    // These events are generated by the other robot
    try {
        impl->memoryProxyRemote->subscribeToEvent("CallChildJA", "JointAttentionInterface", "callChild");
        impl->memoryProxyRemote->subscribeToEvent("EndSessionJA", "JointAttentionInterface", "endSession");
    }
    catch (const AL::ALError& e) {
        qiLogError("JointAttentionInterface") << "Error subscribing to events: " << e.toString() << std::endl;
    }
    // Raise event that the session should start
    impl->memoryProxy->raiseEvent("StartSessionJA", AL::ALValue(1));
    qiLogWarning("JointAttentionInterface") << "Event StartSession raised\n";
}

void JointAttentionInterface::callChild(const std::string &key, const AL::ALValue &value, const AL::ALValue &msg) {
    // Thread safety
    AL::ALCriticalSection section(impl->fCallbackMutex);
    // Unsubscribing
    impl->memoryProxyRemote->unsubscribeToEvent("CallChildJA", "JointAttentionInterface");

    // Reproduce the sound using ALAudioDevice proxy
    if( (int)value == 1 ) {
        // If event is raised with value 1, call child by name with pointing action towards other robot
        qiLogFatal("JointAttentionInterface") << "Vidi!\n";
        // First call without gesture
        impl->call("/home/nao/naoqi/modules/sounds/vidi.wav", false, 1);
    }
    else if ( (int)value == 2 ) {
        // Event is raised with value 2, use reinforced phrase
        qiLogFatal("JointAttentionInterface") << "Vidi ovo!\n";
        // Use reinforced phrase without gesture
        impl->call("/home/nao/naoqi/modules/sounds/vidi_ovo.wav", false, 2);
    }
    else if( (int)value == 3 ) {
        // Event is raised with value 3, use reinforced phrase with gesture
        qiLogFatal("JointAttentionInterface") << "Vidi ovo + gesta!\n";
        // Use reinforced phrase with gesture
        impl->call("/home/nao/naoqi/modules/sounds/vidi_ovo.wav", true, 3);
    }
    // Notify the Logger module that child was called
    impl->memoryProxy->raiseEvent("ChildCalledJA", value);

    // Subscribe to the CallChild event again
    impl->memoryProxyRemote->subscribeToEvent("CallChildJA", "JointAttentionInterface", "callChild");
}

void JointAttentionInterface::endSession() {
    // Thread safety
    AL::ALCriticalSection section(impl->fCallbackMutex);
    // Unsubscribe
    try {
        impl->memoryProxyRemote->unsubscribeToEvent("EndSessionJA", "JointAttentionInterface");
    }
    catch (const AL::ALError& e) {
        qiLogError("JointAttentionInterface") << "Error managing events while reseting" << e.toString() << std::endl;
    }
    // Reset subscriptions
    try {
        impl->memoryProxyRemote->unsubscribeToEvent("CallChildJA", "JointAttentionInterface");
    }
    catch (const AL::ALError& e) {
        qiLogError("JointAttentionInterface") << "Error managing events while reseting" << e.toString() << std::endl;
    }
    impl->started = false;
}

//void Interface::setRemoteConnection(std::string& IP, int& port) {
//    impl->remoteIP = IP;
//    impl->remotePort = port;
//    // Open proxy to ALMemory of the other robot
//    try{
//        impl->memoryProxyRemote = boost::shared_ptr<AL::ALMemoryProxy>(new AL::ALMemoryProxy(impl->remoteIP, impl->remotePort));
//    }
//    catch (const AL::ALError& e) {
//        qiLogError("Interface") << "Error connecting to the other robot: " << e.toString() << std::endl;
//    }
//}

void JointAttentionInterface::enableTask(const std::string &IP, const int &port) {
    impl->remoteIP = IP;
    impl->remotePort = port;
    // Open proxy to ALMemory of the other robot
    try{
        impl->memoryProxyRemote = boost::shared_ptr<AL::ALMemoryProxy>(new AL::ALMemoryProxy(impl->remoteIP, impl->remotePort));
    }
    catch (const AL::ALError& e) {
        qiLogError("JointAttentionInterface") << "Error connecting to the other robot: " << e.toString() << std::endl;
    }
}
